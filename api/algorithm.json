[
  {
    "id": 326,
    "word": "リスト",
    "description": "データを順序付けて格納する基本的なデータ構造の総称。配列や連結リストなどがある。"
  },
  {
    "id": 327,
    "word": "単方向リスト",
    "description": "各ノード（要素）がデータと「次のノードへのポインタ（参照）」だけを持つ連結リスト。一方向にのみ辿れる。"
  },
  {
    "id": 328,
    "word": "スタック",
    "description": "データを入れた順序とは逆の順序で取り出すデータ構造 (LIFO: Last-In, First-Out)。後入れ先出し。"
  },
  {
    "id": 329,
    "word": "ポップ",
    "description": "スタックからデータを取り出す操作のこと。"
  },
  {
    "id": 330,
    "word": "葉",
    "description": "木構造において、子ノードを持たない末端のノードのこと。リーフノード。"
  },
  {
    "id": 331,
    "word": "完全2分木",
    "description": "2分木の一種。最後のレベルを除いて全レベルが埋まっており、最後のレベルは左から順にノードが詰められている木。"
  },
  {
    "id": 332,
    "word": "多分木",
    "description": "各ノードが2つを超える子ノードを持つことができる木構造。N分木。"
  },
  {
    "id": 333,
    "word": "B木",
    "description": "データベースやファイルシステムで用いられる、バランスの取れた多分探索木。大量データを効率的に扱える。"
  },
  {
    "id": 334,
    "word": "幅優先探索",
    "description": "グラフや木の探索手法。始点から近いノード（同じ深さのノード）を順に探索していく。BFS。"
  },
  {
    "id": 335,
    "word": "中間順",
    "description": "2分木の走査（巡回）方法の一つ。「左の子 → 自分自身 → 右の子」の順で訪問する。通りがけ順。"
  },
  {
    "id": 336,
    "word": "配列",
    "description": "同じ型のデータを、連続したメモリ領域に順序付けて格納するデータ構造。インデックスで高速にアクセスできる。"
  },
  {
    "id": 337,
    "word": "双方向リスト",
    "description": "各ノードがデータと「次ノードへのポインタ」および「前ノードへのポインタ」を持つ連結リスト。双方向に辿れる。"
  },
  {
    "id": 338,
    "word": "キュー",
    "description": "データを入れた順序と同じ順序で取り出すデータ構造 (FIFO: First-In, First-Out)。先入れ先出し。待ち行列。"
  },
  {
    "id": 339,
    "word": "木構造",
    "description": "1つの根（ルート）から始まり、階層的にノードが枝分かれしていくデータ構造。親子関係で表される。"
  },
  {
    "id": 340,
    "word": "枝",
    "description": "木構造やグラフ構造において、ノードとノードを結ぶ線のこと。エッジ。"
  },
  {
    "id": 341,
    "word": "バランス木",
    "description": "木の高さが偏らないように、自動的に構造を調整（平衡）する機能を持つ探索木。平衡木。"
  },
  {
    "id": 342,
    "word": "探索木",
    "description": "データを効率的に検索（探索）できるように構成された木構造。2分探索木が代表的。"
  },
  {
    "id": 343,
    "word": "AVL木",
    "description": "バランス木の一種。どのノードも左右の部分木の高さの差が最大1になるよう自動で平衡を保つ2分探索木。"
  },
  {
    "id": 344,
    "word": "先行順",
    "description": "木構造の走査（巡回）方法の一つ。「自分自身 → 左の子 → 右の子」の順で訪問する。行きがけ順。"
  },
  {
    "id": 345,
    "word": "線形リスト",
    "description": "配列や連結リストのように、データが一列に直線的に並んだデータ構造。"
  },
  {
    "id": 346,
    "word": "環状リスト",
    "description": "連結リストの一種で、最後のノードが先頭のノードを指している（ループしている）構造。循環リスト。"
  },
  {
    "id": 347,
    "word": "プッシュ",
    "description": "スタックにデータを追加（挿入）する操作のこと。"
  },
  {
    "id": 348,
    "word": "根",
    "description": "木構造において、階層の最上位にある、親を持たないノードのこと。ルートノード。"
  },
  {
    "id": 349,
    "word": "2分木",
    "description": "すべてのノードが最大でも2つの子ノード（左の子、右の子）しか持たない木構造。"
  },
  {
    "id": 350,
    "word": "順序木",
    "description": "木構造において、兄弟ノード間の順序（左から右など）に意味がある木。"
  },
  {
    "id": 351,
    "word": "2分探索木",
    "description": "2分木の一種で、各ノードが「左の子孫 < 自分 < 右の子孫」という大小関係の性質を持つ木。"
  },
  {
    "id": 352,
    "word": "深さ優先探索",
    "description": "グラフや木の探索手法。可能な限り深く（遠く）のノードを優先して探索し、行き止まりになったら戻る。DFS。"
  },
  {
    "id": 353,
    "word": "後行順",
    "description": "木構造の走査（巡回）方法の一つ。「左の子 → 右の子 → 自分自身」の順で訪問する。帰りがけ順。"
  },
  {
    "id": 354,
    "word": "流れ図",
    "description": "アルゴリズムやプロセスの手順を、標準化された図形や記号を用いて視覚的に表現した図。フローチャート。"
  },
  {
    "id": 355,
    "word": "マージソート",
    "description": "データを分割し、それぞれをソートしてから併合（マージ）することを繰り返す、安定なソートアルゴリズム。"
  },
  {
    "id": 356,
    "word": "クイックソート",
    "description": "ある基準値（ピボット）を選び、それより小さいグループと大きいグループに分割し、再帰的にソートするアルゴリズム。"
  },
  {
    "id": 357,
    "word": "2分探索法",
    "description": "ソート済みの配列やリストから、探索範囲の中央値と比較しながら効率的に目的のデータを見つけるアルゴリズム。"
  },
  {
    "id": 358,
    "word": "深さ優先探索",
    "description": "グラフや木構造の探索において、可能な限り深く（先に）探索し、行き止まったら戻って別の分岐を探索する手法。DFS。"
  },
  {
    "id": 359,
    "word": "ダイクストラ法",
    "description": "グラフ上の単一始点から他の全ノードへの最短経路を求めるアルゴリズム。辺の重みが負でない場合に用いられる。"
  },
  {
    "id": 360,
    "word": "形態素解析",
    "description": "自然言語処理において、文章を意味を持つ最小単位（形態素）に分割し、それぞれの品詞を判別する技術。"
  },
  {
    "id": 361,
    "word": "文脈解析",
    "description": "自然言語処理において、単語や文の意味を、前後の文脈を考慮して解釈する技術。"
  },
  {
    "id": 362,
    "word": "文章間類似度",
    "description": "2つ（または複数）の文章が、内容や意味においてどれだけ似ているかを数値で表す指標。"
  },
  {
    "id": 363,
    "word": "選択ソート",
    "description": "未ソート部分から最小値（または最大値）を見つけ出し、ソート済み部分の末尾に追加していく単純なソートアルゴリズム。"
  },
  {
    "id": 364,
    "word": "挿入ソート",
    "description": "未ソート部分の先頭要素を、ソート済み部分の適切な位置に挿入していくことを繰り返すソートアルゴリズム。"
  },
  {
    "id": 365,
    "word": "ヒープソート",
    "description": "データ全体でヒープ（二分木）構造を構築し、最大値（または最小値）を順に取り出してソートするアルゴリズム。"
  },
  {
    "id": 366,
    "word": "ハッシュ表探索法",
    "description": "データとそれを格納する配列の添え字をハッシュ関数で関連付ける（ハッシュ表）ことで、高速な探索を実現する手法。"
  },
  {
    "id": 367,
    "word": "幅優先探索",
    "description": "グラフや木構造の探索において、始点に近いノードから順に、横に広がるように探索する手法。BFS。"
  },
  {
    "id": 368,
    "word": "ベルマンフォード法",
    "description": "グラフ上の単一始点からの最短経路を求めるアルゴリズム。辺の重みが負であっても（負の閉路がなければ）動作する。"
  },
  {
    "id": 369,
    "word": "構文解析",
    "description": "自然言語処理やプログラミング言語において、文の構造（主語、動詞など）や文法的な正しさを解析すること。パーシング。"
  },
  {
    "id": 370,
    "word": "係り受け解析",
    "description": "自然言語処理において、文中の単語（文節）間の修飾・被修飾の関係（係り受け関係）を解析すること。"
  },
  {
    "id": 371,
    "word": "再帰性",
    "description": "ある関数や手続きが、その定義の中で自分自身を呼び出す性質。Recursiveness。"
  },
  {
    "id": 372,
    "word": "バブルソート",
    "description": "隣り合う要素を比較して交換することを繰り返し、リストの端から順に値を整列させる単純なソートアルゴリズム。"
  },
  {
    "id": 373,
    "word": "シェルソート",
    "description": "挿入ソートを改良したアルゴリズム。一定間隔おきの要素群で挿入ソートを行い、その間隔を狭めながら繰り返す。"
  },
  {
    "id": 374,
    "word": "線形探索法",
    "description": "配列やリストの先頭から順に、目的のデータが見つかるまで探索する最も単純な探索アルゴリズム。"
  },
  {
    "id": 375,
    "word": "再帰的アルゴリズム",
    "description": "アルゴリズムの内部で、それ自身の処理をより小さな部分問題に対して呼び出す（再帰）ことで解を求める手法。"
  },
  {
    "id": 376,
    "word": "最短経路探索",
    "description": "グラフ上の2つのノード間を結ぶ経路のうち、コスト（距離や時間）が最小となる経路を見つけるアルゴリズムの総称。"
  },
  {
    "id": 377,
    "word": "文字列照合",
    "description": "ある長いテキスト（本文）の中から、特定の短い文字列（パターン）が出現する位置を見つけるアルゴリズム。"
  },
  {
    "id": 378,
    "word": "意味解析",
    "description": "自然言語処理やコンパイラにおいて、構文解析された文がどのような意味を持つかを解釈する処理。"
  },
  {
    "id": 380,
    "word": "分割統治法",
    "description": "大きな問題を、直接解ける小さな問題に分割し、それぞれの解を組み合わせて元の問題の解を得るアルゴリズム設計手法。"
  },
  {
    "id": 381,
    "word": "プログラミング",
    "description": "コンピュータに実行させたい処理を、プログラミング言語を用いて一連の命令（プログラム）として記述すること。"
  },

  {
    "id": 384,
    "word": "メインルーチン",
    "description": "プログラムが実行されたときに最初に呼び出され、全体の処理の流れを制御する中心的な部分。"
  },
  {
    "id": 385,
    "word": "実数型",
    "description": "小数点以下の値を含む数（実数）を扱うためのデータ型。浮動小数点数型など。"
  },
  {
    "id": 386,
    "word": "文字列型",
    "description": "複数の文字の連なり（文字列）を扱うためのデータ型。"
  },
  {
    "id": 387,
    "word": "代入",
    "description": "変数に値や計算結果を格納する操作。"
  },
  {
    "id": 388,
    "word": "論理演算",
    "description": "真（True）と偽（False）の値に対して行う演算。AND、OR、NOTなど。"
  },
  {
    "id": 389,
    "word": "繰返し処理",
    "description": "特定の条件が満たされている間、同じ処理を何度も実行する制御構造。ループ。for文やwhile文など。"
  },
  {
    "id": 390,
    "word": "局所変数",
    "description": "関数やブロックの内部で宣言され、その中でのみ有効な変数。ローカル変数。"
  },
  {
    "id": 391,
    "word": "メンバ変数",
    "description": "オブジェクト指向において、クラスの内部で定義され、そのオブジェクトの状態を保持する変数。フィールド。"
  },
  {
    "id": 392,
    "word": "Webプログラミング",
    "description": "WebサイトやWebアプリケーションなど、Web上で動作するシステムを開発する技術の総称。"
  },
  {
    "id": 393,
    "word": "Ajax",
    "description": "Asynchronous JavaScript + XML。Webページ全体を再読み込みせず、サーバと非同期に通信して動的にページの一部を更新する技術。"
  },
  {
    "id": 394,
    "word": "コーディング標準",
    "description": "プログラムの可読性や保守性を高めるために、変数名の付け方やインデントなどの書き方を定めた規約。"
  },
  {
    "id": 395,
    "word": "命名規則",
    "description": "変数名、関数名、クラス名などの識別子に名前を付ける際のルール。キャメルケースやスネークケースなど。"
  },
  {
    "id": 396,
    "word": "モジュール分割",
    "description": "大規模なプログラムを、機能や役割ごとに小さな独立した部品（モジュール）に分割して開発する手法。"
  },
  {
    "id": 397,
    "word": "サブルーチン",
    "description": "特定の処理をひとまとめにしたプログラムの部品。関数やプロシージャ。メインルーチンから呼び出して使う。"
  },
  {
    "id": 398,
    "word": "論理型",
    "description": "真（True）または偽（False）のどちらかの値のみをとるデータ型。ブール型。"
  },
  {
    "id": 399,
    "word": "抽象データ型",
    "description": "データの型を、その内部構造ではなく、そのデータに対して行える操作（仕様）によって定義する考え方。"
  },
  {
    "id": 400,
    "word": "算術演算",
    "description": "数値に対して行う基本的な計算。加算（+）、減算（-）、乗算（*）、除算（/）など。"
  },
  {
    "id": 401,
    "word": "ビット演算",
    "description": "数値を2進数のビット列として扱い、ビット単位で行う論理演算（AND、OR、XOR）やシフト演算。"
  },
  {
    "id": 402,
    "word": "引数",
    "description": "関数やサブルーチンを呼び出す際に、外部から渡す値。処理内容を変化させるために使う。パラメータ。"
  },
  {
    "id": 403,
    "word": "オブジェクト指向プログラミング",
    "description": "プログラムを「モノ（オブジェクト）」の集まりとして捉え、その相互作用として設計・開発する手法。OOP。"
  },
  {
    "id": 404,
    "word": "オーバーライド",
    "description": "オブジェクト指向において、親クラス（スーパークラス）で定義されたメソッドを、子クラス（サブクラス）で再定義すること。"
  },
  {
    "id": 405,
    "word": "サーバサイドプログラミング",
    "description": "Webサーバ上で動作し、データベース連携やリクエストに応じた動的なWebページ生成などを行うプログラミング。"
  },
  {
    "id": 406,
    "word": "Apache",
    "description": "Apache HTTP Server。世界的に広く利用されている、オープンソースのWebサーバソフトウェア。"
  },
  {
    "id": 407,
    "word": "字下げ",
    "description": "プログラムの制御構造を視覚的に分かりやすくするため、行頭に空白（スペースやタブ）を挿入すること。インデント。"
  },
  {
    "id": 408,
    "word": "使用禁止命令",
    "description": "プログラムの品質やセキュリティを低下させる危険があるため、使用が推奨されない、または禁止されている命令や関数。"
  },
  {
    "id": 409,
    "word": "モジュール独立性",
    "description": "各モジュールが他のモジュールにどれだけ依存していないかを示す度合い。独立性が高いほど保守性や再利用性が向上する。"
  },
  {
    "id": 410,
    "word": "整数型",
    "description": "小数点を含まない数（整数）を扱うためのデータ型。"
  },
  {
    "id": 411,
    "word": "文字型",
    "description": "1つの文字（'a'や'1'など）を扱うためのデータ型。"
  },
  {
    "id": 412,
    "word": "構造型",
    "description": "複数の異なるデータ型（整数型、文字型など）を組み合わせて、一つのまとまりとして定義したデータ型。構造体。"
  },
  {
    "id": 413,
    "word": "比較演算",
    "description": "2つの値の大小関係や等価性を比較する演算。結果は真（True）または偽（False）となる。==、!=、>、< など。"
  },
  {
    "id": 414,
    "word": "選択処理",
    "description": "ある条件が満たされているかどうかによって、次に実行する処理を分岐させる制御構造。if文やswitch文など。"
  },
  {
    "id": 415,
    "word": "戻り値",
    "description": "関数やサブルーチンが処理を終了した際に、呼び出し元に返す値。返り値。"
  },
  {
    "id": 416,
    "word": "コンストラクタ",
    "description": "オブジェクト指向において、クラスからオブジェクトを生成（インスタンス化）する際に、初期化のために自動的に呼び出されるメソッド。"
  },
  {
    "id": 417,
    "word": "オーバーロード",
    "description": "同じクラス内（または同じスコープ内）で、メソッド（関数）名が同じで、引数の型や個数が異なるメソッドを複数定義すること。"
  },
  {
    "id": 418,
    "word": "リッチクライアント",
    "description": "Webアプリケーションにおいて、従来のWebブラウザよりも高度な表現力や操作性を持つクライアント側の実行環境や技術。"
  },
  {
    "id": 419,
    "word": "フロントエンドフレームワーク",
    "description": "Webアプリケーションのユーザインターフェース（フロントエンド）開発を効率化するための枠組みやライブラリ群。React、Vue.jsなど。"
  }
]