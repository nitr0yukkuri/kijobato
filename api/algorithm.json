[
  {
    "id": 326,
    "word": "リスト",
    "description": "データを順序付けて格納する基本的なデータ構造の総称。配列や連結リストなどがある。"
  },
  {
    "id": 327,
    "word": "単方向リスト",
    "description": "各ノード（要素）がデータと「次のノードへのポインタ（参照）」だけを持つ連結リスト。一方向にのみ辿れる。"
  },
  {
    "id": 328,
    "word": "スタック",
    "description": "データを入れた順序とは逆の順序で取り出すデータ構造 (LIFO: Last-In, First-Out)。後入れ先出し。"
  },
  {
    "id": 329,
    "word": "ポップ",
    "description": "スタックからデータを取り出す操作のこと。"
  },
  {
    "id": 330,
    "word": "葉",
    "description": "木構造において、子ノードを持たない末端のノードのこと。リーフノード。"
  },
  {
    "id": 331,
    "word": "完全2分木",
    "description": "2分木の一種。最後のレベルを除いて全レベルが埋まっており、最後のレベルは左から順にノードが詰められている木。"
  },
  {
    "id": 332,
    "word": "多分木",
    "description": "各ノードが2つを超える子ノードを持つことができる木構造。N分木。"
  },
  {
    "id": 333,
    "word": "B木",
    "description": "データベースやファイルシステムで用いられる、バランスの取れた多分探索木。大量データを効率的に扱える。"
  },
  {
    "id": 334,
    "word": "幅優先探索",
    "description": "グラフや木の探索手法。始点から近いノード（同じ深さのノード）を順に探索していく。BFS。"
  },
  {
    "id": 335,
    "word": "中間順",
    "description": "2分木の走査（巡回）方法の一つ。「左の子 → 自分自身 → 右の子」の順で訪問する。通りがけ順。"
  },
  {
    "id": 336,
    "word": "配列",
    "description": "同じ型のデータを、連続したメモリ領域に順序付けて格納するデータ構造。インデックスで高速にアクセスできる。"
  },
  {
    "id": 337,
    "word": "双方向リスト",
    "description": "各ノードがデータと「次ノードへのポインタ」および「前ノードへのポインタ」を持つ連結リスト。双方向に辿れる。"
  },
  {
    "id": 338,
    "word": "キュー",
    "description": "データを入れた順序と同じ順序で取り出すデータ構造 (FIFO: First-In, First-Out)。先入れ先出し。待ち行列。"
  },
  {
    "id": 339,
    "word": "木構造",
    "description": "1つの根（ルート）から始まり、階層的にノードが枝分かれしていくデータ構造。親子関係で表される。"
  },
  {
    "id": 340,
    "word": "枝",
    "description": "木構造やグラフ構造において、ノードとノードを結ぶ線のこと。エッジ。"
  },
  {
    "id": 341,
    "word": "バランス木",
    "description": "木の高さが偏らないように、自動的に構造を調整（平衡）する機能を持つ探索木。平衡木。"
  },
  {
    "id": 342,
    "word": "探索木",
    "description": "データを効率的に検索（探索）できるように構成された木構造。2分探索木が代表的。"
  },
  {
    "id": 343,
    "word": "AVL木",
    "description": "バランス木の一種。どのノードも左右の部分木の高さの差が最大1になるよう自動で平衡を保つ2分探索木。"
  },
  {
    "id": 344,
    "word": "先行順",
    "description": "木構造の走査（巡回）方法の一つ。「自分自身 → 左の子 → 右の子」の順で訪問する。行きがけ順。"
  },
  {
    "id": 345,
    "word": "線形リスト",
    "description": "配列や連結リストのように、データが一列に直線的に並んだデータ構造。"
  },
  {
    "id": 346,
    "word": "環状リスト",
    "description": "連結リストの一種で、最後のノードが先頭のノードを指している（ループしている）構造。循環リスト。"
  },
  {
    "id": 347,
    "word": "プッシュ",
    "description": "スタックにデータを追加（挿入）する操作のこと。"
  },
  {
    "id": 348,
    "word": "根",
    "description": "木構造において、階層の最上位にある、親を持たないノードのこと。ルートノード。"
  },
  {
    "id": 349,
    "word": "2分木",
    "description": "すべてのノードが最大でも2つの子ノード（左の子、右の子）しか持たない木構造。"
  },
  {
    "id": 350,
    "word": "順序木",
    "description": "木構造において、兄弟ノード間の順序（左から右など）に意味がある木。"
  },
  {
    "id": 351,
    "word": "2分探索木",
    "description": "2分木の一種で、各ノードが「左の子孫 < 自分 < 右の子孫」という大小関係の性質を持つ木。"
  },
  {
    "id": 352,
    "word": "深さ優先探索",
    "description": "グラフや木の探索手法。可能な限り深く（遠く）のノードを優先して探索し、行き止まりになったら戻る。DFS。"
  },
  {
    "id": 353,
    "word": "後行順",
    "description": "木構造の走査（巡回）方法の一つ。「左の子 → 右の子 → 自分自身」の順で訪問する。帰りがけ順。"
  },
  {
    "id": 354,
    "word": "流れ図",
    "description": "アルゴリズムやプロセスの手順を、標準化された図形や記号を用いて視覚的に表現した図。フローチャート。"
  },
  {
    "id": 355,
    "word": "マージソート",
    "description": "データを分割し、それぞれをソートしてから併合（マージ）することを繰り返す、安定なソートアルゴリズム。"
  },
  {
    "id": 356,
    "word": "クイックソート",
    "description": "ある基準値（ピボット）を選び、それより小さいグループと大きいグループに分割し、再帰的にソートするアルゴリズム。"
  },
  {
    "id": 357,
    "word": "2分探索法",
    "description": "ソート済みの配列やリストから、探索範囲の中央値と比較しながら効率的に目的のデータを見つけるアルゴリズム。"
  },
  {
    "id": 358,
    "word": "深さ優先探索",
    "description": "グラフや木構造の探索において、可能な限り深く（先に）探索し、行き止まったら戻って別の分岐を探索する手法。DFS。"
  },
  {
    "id": 359,
    "word": "ダイクストラ法",
    "description": "グラフ上の単一始点から他の全ノードへの最短経路を求めるアルゴリズム。辺の重みが負でない場合に用いられる。"
  },
  {
    "id": 360,
    "word": "形態素解析",
    "description": "自然言語処理において、文章を意味を持つ最小単位（形態素）に分割し、それぞれの品詞を判別する技術。"
  },
  {
    "id": 361,
    "word": "文脈解析",
    "description": "自然言語処理において、単語や文の意味を、前後の文脈を考慮して解釈する技術。"
  },
  {
    "id": 362,
    "word": "文章間類似度",
    "description": "2つ（または複数）の文章が、内容や意味においてどれだけ似ているかを数値で表す指標。"
  },
  {
    "id": 363,
    "word": "選択ソート",
    "description": "未ソート部分から最小値（または最大値）を見つけ出し、ソート済み部分の末尾に追加していく単純なソートアルゴリズム。"
  },
  {
    "id": 364,
    "word": "挿入ソート",
    "description": "未ソート部分の先頭要素を、ソート済み部分の適切な位置に挿入していくことを繰り返すソートアルゴリズム。"
  },
  {
    "id": 365,
    "word": "ヒープソート",
    "description": "データ全体でヒープ（二分木）構造を構築し、最大値（または最小値）を順に取り出してソートするアルゴリズム。"
  },
  {
    "id": 366,
    "word": "ハッシュ表探索法",
    "description": "データとそれを格納する配列の添え字をハッシュ関数で関連付ける（ハッシュ表）ことで、高速な探索を実現する手法。"
  },
  {
    "id": 367,
    "word": "幅優先探索",
    "description": "グラフや木構造の探索において、始点に近いノードから順に、横に広がるように探索する手法。BFS。"
  },
  {
    "id": 368,
    "word": "ベルマンフォード法",
    "description": "グラフ上の単一始点からの最短経路を求めるアルゴリズム。辺の重みが負であっても（負の閉路がなければ）動作する。"
  },
  {
    "id": 369,
    "word": "構文解析",
    "description": "自然言語処理やプログラミング言語において、文の構造（主語、動詞など）や文法的な正しさを解析すること。パーシング。"
  },
  {
    "id": 370,
    "word": "係り受け解析",
    "description": "自然言語処理において、文中の単語（文節）間の修飾・被修飾の関係（係り受け関係）を解析すること。"
  },
  {
    "id": 371,
    "word": "再帰性",
    "description": "ある関数や手続きが、その定義の中で自分自身を呼び出す性質。Recursiveness。"
  },
  {
    "id": 372,
    "word": "バブルソート",
    "description": "隣り合う要素を比較して交換することを繰り返し、リストの端から順に値を整列させる単純なソートアルゴリズム。"
  },
  {
    "id": 373,
    "word": "シェルソート",
    "description": "挿入ソートを改良したアルゴリズム。一定間隔おきの要素群で挿入ソートを行い、その間隔を狭めながら繰り返す。"
  },
  {
    "id": 374,
    "word": "線形探索法",
    "description": "配列やリストの先頭から順に、目的のデータが見つかるまで探索する最も単純な探索アルゴリズム。"
  },
  {
    "id": 375,
    "word": "再帰的アルゴリズム",
    "description": "アルゴリズムの内部で、それ自身の処理をより小さな部分問題に対して呼び出す（再帰）ことで解を求める手法。"
  },
  {
    "id": 376,
    "word": "最短経路探索",
    "description": "グラフ上の2つのノード間を結ぶ経路のうち、コスト（距離や時間）が最小となる経路を見つけるアルゴリズムの総称。"
  },
  {
    "id": 377,
    "word": "文字列照合",
    "description": "ある長いテキスト（本文）の中から、特定の短い文字列（パターン）が出現する位置を見つけるアルゴリズム。"
  },
  {
    "id": 378,
    "word": "意味解析",
    "description": "自然言語処理やコンパイラにおいて、構文解析された文がどのような意味を持つかを解釈する処理。"
  },
  {
    "id": 380,
    "word": "分割統治法",
    "description": "大きな問題を、直接解ける小さな問題に分割し、それぞれの解を組み合わせて元の問題の解を得るアルゴリズム設計手法。"
  }
]